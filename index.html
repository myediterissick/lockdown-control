<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Lockdown Control (Prototype)</title>
<style>
  html, body { margin:0; padding:0; background:#000; color:#d6ffd6; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; user-select:none; }
  #wrap { display:flex; justify-content:center; align-items:center; min-height:100vh; flex-direction:column; gap:10px; }
  canvas { background:#050505; border:2px solid #1cff7a33; border-radius:12px; }
  .panel { width:min(980px, 96vw); display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
  .box { border:1px solid #1cff7a33; border-radius:12px; padding:10px 12px; background:#041006; }
  button { background:#0c2815; color:#d6ffd6; border:1px solid #1cff7a55; padding:10px 12px; border-radius:10px; cursor:pointer; }
  button:hover { filter:brightness(1.2); }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .muted { color:#98c998; font-size:12px; }
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .title { font-weight:700; letter-spacing:1px; }
</style>
</head>
<body>
<div id="wrap">
  <div class="panel">
    <div class="box">
      <div class="title">LOCKDOWN CONTROL</div>
      <div class="muted">
        Aim flashlight with mouse. Toggle flashlight: <b>F</b>. Toggle traps: click the trap bars. No backups.
        <br/>Close a trap when an enemy is close to it to <b>capture</b> them.
      </div>
    </div>

    <div class="box row" id="menuBox">
      <span class="muted">Difficulty:</span>
      <button id="easyBtn">Easy</button>
      <button id="medBtn">Medium</button>
      <button id="hardBtn">Hard</button>
      <button id="nightBtn">Nightmare</button>
      <span class="muted" id="menuHint">Pick one to start</span>
    </div>

    <div class="box row" id="hudBox" style="display:none;">
      <div>ðŸ”¦ Flash: <b id="flashVal">100.0%</b></div>
      <div>ðŸšª Door: <b id="doorVal">100.0%</b></div>
      <div>Mode: <b id="modeVal">â€”</b></div>
      <div>Enemies: <b id="enemyVal">â€”</b></div>
      <button id="restartBtn">Restart</button>
    </div>
  </div>

  <canvas id="game" width="980" height="620"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const hudBox = document.getElementById("hudBox");
  const menuBox = document.getElementById("menuBox");
  const flashVal = document.getElementById("flashVal");
  const doorVal  = document.getElementById("doorVal");
  const modeVal  = document.getElementById("modeVal");
  const enemyVal = document.getElementById("enemyVal");

  const restartBtn = document.getElementById("restartBtn");
  const easyBtn = document.getElementById("easyBtn");
  const medBtn  = document.getElementById("medBtn");
  const hardBtn = document.getElementById("hardBtn");
  const nightBtn= document.getElementById("nightBtn");

  // ===== Your rules =====
  const DIFFS = {
    easy:      { total: 2,  speed: 0.070 }, // slow
    medium:    { total: 4,  speed: 0.095 }, // ok
    hard:      { total: 7,  speed: 0.120 }, // medium-fast
    nightmare: { total: 10, speed: 0.150 }, // fast
  };

  // Drain rules
  const FLASH_DRAIN_PER_SEC = 0.1; // 0.1%/sec while flashlight ON
  const DOOR_DRAIN_PER_SEC  = 0.2; // 0.2%/sec per CLOSED door IF enemies in that section

  // Flashlight beam (small so you find enemies individually)
  const BEAM_RADIUS = 42;

  // Door position (near control room)
  const DOOR_PROGRESS = 0.78;

  // Capture zone: enemy must be close enough to the door when you close it
  // (this makes the trap feel fair + skill based)
  const CAPTURE_MIN_PROGRESS = 0.68;

  const LOSE_PROGRESS = 1.0;

  // ===== Layout =====
  const center = { x: canvas.width/2, y: canvas.height/2 + 10 };
  const roomRadius = 68;

  const sectionAngles = [
    -90,  -18,   54,  126,  198
  ].map(d => d * Math.PI/180);

  const corridorLen = 250;
  const corridorWidth = 92;

  let doorRects = []; // click targets

  // ===== State =====
  let running = false;
  let difficulty = null;

  let flashlightBattery = 100.0;
  let doorBattery = 100.0;
  let flashlightOn = false;

  let mouse = { x: center.x, y: center.y, inside: false };

  const doors = new Array(5).fill(0).map(() => ({ closed:false }));

  // enemies: { section, progress, lateral, id }
  let enemies = [];

  // ===== Helpers =====
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function dist(ax, ay, bx, by) { return Math.hypot(ax-bx, ay-by); }

  function sectionToWorld(sectionIdx, progress, lateral) {
    const ang = sectionAngles[sectionIdx];
    const outerX = center.x + Math.cos(ang) * (roomRadius + corridorLen);
    const outerY = center.y + Math.sin(ang) * (roomRadius + corridorLen);
    const innerX = center.x + Math.cos(ang) * (roomRadius + 10);
    const innerY = center.y + Math.sin(ang) * (roomRadius + 10);

    const t = clamp(progress, 0, 1);
    const x = outerX + (innerX - outerX) * t;
    const y = outerY + (innerY - outerY) * t;

    const px = -Math.sin(ang);
    const py =  Math.cos(ang);

    const off = lateral * (corridorWidth * 0.35);
    return { x: x + px*off, y: y + py*off };
  }

  function enemyIsIlluminated(enemy) {
    if (!flashlightOn || flashlightBattery <= 0) return false;
    const p = sectionToWorld(enemy.section, enemy.progress, enemy.lateral);
    return dist(p.x, p.y, mouse.x, mouse.y) <= BEAM_RADIUS;
  }

  function enemiesInSection(idx) {
    return enemies.filter(e => e.section === idx);
  }

  function computeDistribution(diffKey) {
    if (diffKey === "easy") {
      return [1,1,0,0,0].sort(() => Math.random()-0.5);
    }
    if (diffKey === "medium") {
      return [1,1,1,1,0].sort(() => Math.random()-0.5);
    }
    if (diffKey === "hard") {
      return [2,2,2,1,0].sort(() => Math.random()-0.5);
    }
    return [2,2,2,2,2]; // nightmare
  }

  function spawnEnemies(diffKey) {
    const distArr = computeDistribution(diffKey);
    const list = [];
    let id = 0;

    for (let s = 0; s < 5; s++) {
      const count = distArr[s];
      for (let k = 0; k < count; k++) {
        const startProg = 0.00 + Math.random()*0.12;
        let lat = (count === 2)
          ? (k === 0 ? -0.55 : 0.55)
          : (Math.random()*1.1 - 0.55);

        list.push({
          id: id++,
          section: s,
          progress: startProg,
          lateral: clamp(lat, -0.85, 0.85)
        });
      }
    }
    return list.sort(() => Math.random() - 0.5);
  }

  function resetAll() {
    flashlightBattery = 100.0;
    doorBattery = 100.0;
    flashlightOn = false;
    enemies = [];
    for (const d of doors) d.closed = false;
    doorRects = [];
  }

  // ===== Input =====
  canvas.addEventListener("mousemove", (e) => {
    const r = canvas.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;
    mouse.inside = (mouse.x >= 0 && mouse.x <= canvas.width && mouse.y >= 0 && mouse.y <= canvas.height);
  });
  canvas.addEventListener("mouseleave", () => mouse.inside = false);

  // TRAP CLICK: close/open + CAPTURE
  canvas.addEventListener("click", (e) => {
    if (!running) return;
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;

    for (const dr of doorRects) {
      if (mx >= dr.x && mx <= dr.x + dr.w && my >= dr.y && my <= dr.y + dr.h) {
        if (doorBattery <= 0) return; // doors failed open when 0

        const idx = dr.idx;
        const wasClosed = doors[idx].closed;
        doors[idx].closed = !wasClosed;

        // If we JUST CLOSED it, capture enemies that are close enough to the door.
        if (!wasClosed && doors[idx].closed) {
          const before = enemies.length;

          enemies = enemies.filter(en => {
            if (en.section !== idx) return true;
            // capture only if enemy is close enough to the door (skill timing)
            return en.progress < CAPTURE_MIN_PROGRESS;
          });

          const captured = before - enemies.length;
          // Update enemy count on HUD immediately
          enemyVal.textContent = enemies.length.toString();

          // Optional tiny feedback without spoilers
          if (captured > 0) {
            // quick flash text using title (simple)
            document.title = `Captured ${captured}!`;
            setTimeout(() => { document.title = "Lockdown Control (Prototype)"; }, 400);
          }
        }
        return;
      }
    }
  });

  window.addEventListener("keydown", (e) => {
    if (!running) return;
    if (e.key.toLowerCase() === "f") {
      if (flashlightBattery > 0) flashlightOn = !flashlightOn;
    }
  });

  // ===== Menu =====
  function start(diffKey) {
    resetAll();
    difficulty = diffKey;
    enemies = spawnEnemies(diffKey);

    modeVal.textContent = diffKey.toUpperCase();
    enemyVal.textContent = enemies.length.toString();

    menuBox.style.display = "none";
    hudBox.style.display = "flex";
    hudBox.style.gap = "12px";
    hudBox.style.flexWrap = "wrap";

    running = true;
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  easyBtn.onclick  = () => start("easy");
  medBtn.onclick   = () => start("medium");
  hardBtn.onclick  = () => start("hard");
  nightBtn.onclick = () => start("nightmare");

  restartBtn.onclick = () => {
    running = false;
    menuBox.style.display = "flex";
    hudBox.style.display = "none";
    resetAll();
    draw();
  };

  // ===== Loop =====
  let lastTime = performance.now();

  function win() {
    running = false;
    alert("YOU WIN â€” All enemies were contained.");
    menuBox.style.display = "flex";
    hudBox.style.display = "none";
    resetAll();
    draw();
  }

  function gameOver() {
    running = false;
    alert("YOU LOST â€” An enemy reached the control room.");
    menuBox.style.display = "flex";
    hudBox.style.display = "none";
    resetAll();
    draw();
  }

  function update(dt) {
    if (!difficulty) return;

    // Flashlight drain
    if (flashlightOn && flashlightBattery > 0) {
      flashlightBattery -= FLASH_DRAIN_PER_SEC * dt;
      flashlightBattery = clamp(flashlightBattery, 0, 100);
      if (flashlightBattery <= 0) flashlightOn = false;
    }

    // Door drain: per closed door only if enemies in that section
    if (doorBattery > 0) {
      let drainingDoors = 0;
      for (let s = 0; s < 5; s++) {
        if (doors[s].closed && enemiesInSection(s).length > 0) drainingDoors++;
      }
      if (drainingDoors > 0) {
        doorBattery -= (DOOR_DRAIN_PER_SEC * drainingDoors) * dt;
        doorBattery = clamp(doorBattery, 0, 100);
      }
    }

    // Door battery 0 => doors fail open
    if (doorBattery <= 0) {
      for (let s = 0; s < 5; s++) doors[s].closed = false;
    }

    // Move enemies unless illuminated; doors block at the door line
    const spd = DIFFS[difficulty].speed;

    for (const e of enemies) {
      const lit = enemyIsIlluminated(e);
      if (lit) continue; // frozen when lit

      const doorClosed = doors[e.section].closed && doorBattery > 0;

      // If door closed, enemy cannot pass the door line
      if (doorClosed && e.progress >= DOOR_PROGRESS) {
        e.progress = DOOR_PROGRESS;
        continue;
      }

      e.progress += spd * dt;

      if (e.progress >= LOSE_PROGRESS) {
        gameOver();
        return;
      }
    }

    // Win if all enemies captured
    if (enemies.length === 0) {
      win();
      return;
    }
  }

  function loop(now) {
    if (!running) return;
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // ===== Draw =====
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // grid glow
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = "#1cff7a";
    for (let x = 0; x < canvas.width; x += 40) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
    }
    for (let y = 0; y < canvas.height; y += 40) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
    }
    ctx.restore();

    doorRects = [];

    for (let s = 0; s < 5; s++) {
      const ang = sectionAngles[s];
      const ax = Math.cos(ang), ay = Math.sin(ang);
      const px = -Math.sin(ang), py = Math.cos(ang);

      const innerX = center.x + ax*(roomRadius + 10);
      const innerY = center.y + ay*(roomRadius + 10);
      const outerX = center.x + ax*(roomRadius + corridorLen);
      const outerY = center.y + ay*(roomRadius + corridorLen);

      const hw = corridorWidth/2;

      const p1 = { x: innerX + px*hw, y: innerY + py*hw };
      const p2 = { x: innerX - px*hw, y: innerY - py*hw };
      const p3 = { x: outerX - px*hw, y: outerY - py*hw };
      const p4 = { x: outerX + px*hw, y: outerY + py*hw };

      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#0b1d12";
      ctx.strokeStyle = "#1cff7a55";
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.lineTo(p4.x, p4.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // label
      ctx.save();
      ctx.fillStyle = "#b6ffcf";
      ctx.font = "14px monospace";
      ctx.globalAlpha = 0.9;
      ctx.fillText(`S${s+1}`, outerX - 10, outerY - 10);
      ctx.restore();

      // door/trap bar at DOOR_PROGRESS
      const doorPoint = sectionToWorld(s, DOOR_PROGRESS, 0);
      const barW = corridorWidth * 0.72;
      const barH = 12;

      const dr = { idx:s, x:doorPoint.x - barW/2, y:doorPoint.y - barH/2, w:barW, h:barH };
      doorRects.push(dr);

      const closed = doors[s].closed && doorBattery > 0;

      ctx.save();
      ctx.fillStyle = closed ? "#1cff7a" : "#1cff7a22";
      ctx.strokeStyle = "#1cff7a66";
      ctx.lineWidth = 2;
      ctx.fillRect(dr.x, dr.y, dr.w, dr.h);
      ctx.strokeRect(dr.x, dr.y, dr.w, dr.h);

      ctx.fillStyle = "#041006";
      ctx.globalAlpha = closed ? 0.95 : 0.55;
      ctx.font = "11px monospace";
      ctx.fillText(closed ? "TRAP CLOSED" : "TRAP OPEN", dr.x + 8, dr.y + 9);
      ctx.restore();
    }

    // control room
    ctx.save();
    ctx.fillStyle = "#071a10";
    ctx.strokeStyle = "#1cff7a88";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(center.x, center.y, roomRadius, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = "#caffdd";
    ctx.font = "16px monospace";
    ctx.fillText("CONTROL ROOM", center.x - 68, center.y + 6);
    ctx.restore();

    // flashlight beam
    if (running && flashlightOn && flashlightBattery > 0 && mouse.inside) {
      ctx.save();
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(mouse.x, mouse.y, BEAM_RADIUS, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.45;
      ctx.strokeStyle = "#d6ffd6";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(mouse.x, mouse.y, BEAM_RADIUS, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // enemies visible ONLY when directly lit
    for (const e of enemies) {
      const p = sectionToWorld(e.section, e.progress, e.lateral);
      const lit = enemyIsIlluminated(e);
      if (!lit) continue;

      ctx.save();
      ctx.fillStyle = "#ff2a2a";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = "#ffd1d1";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 14, 0, Math.PI*2);
      ctx.stroke();

      ctx.font = "10px monospace";
      ctx.fillStyle = "#ffd1d1";
      ctx.fillText("FOUND", p.x - 16, p.y - 16);
      ctx.restore();
    }

    flashVal.textContent = `${flashlightBattery.toFixed(1)}%`;
    doorVal.textContent  = `${doorBattery.toFixed(1)}%`;
    if (enemyVal) enemyVal.textContent = enemies.length.toString();
  }

  // first draw
  draw();
})();
</script>
</body>
</html>
