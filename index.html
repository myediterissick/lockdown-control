<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Lockdown Control (Prototype)</title>
<style>
  html, body { margin:0; padding:0; background:#000; color:#d6ffd6; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; }
  #wrap { display:flex; justify-content:center; align-items:center; min-height:100vh; flex-direction:column; gap:10px; }
  canvas { background:#050505; border:2px solid #1cff7a33; border-radius:12px; }
  .panel { width:min(980px, 96vw); display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
  .box { border:1px solid #1cff7a33; border-radius:12px; padding:10px 12px; background:#041006; }
  button { background:#0c2815; color:#d6ffd6; border:1px solid #1cff7a55; padding:10px 12px; border-radius:10px; cursor:pointer; }
  button:hover { filter:brightness(1.2); }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .muted { color:#98c998; font-size:12px; }
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .title { font-weight:700; letter-spacing:1px; }
</style>
</head>
<body>
<div id="wrap">
  <div class="panel">
    <div class="box">
      <div class="title">LOCKDOWN CONTROL</div>
      <div class="muted">Aim flashlight with mouse. Toggle flashlight: <b>F</b>. Toggle doors: click door bars (near center). No backups.</div>
    </div>

    <div class="box row" id="menuBox">
      <span class="muted">Difficulty:</span>
      <button id="easyBtn">Easy</button>
      <button id="medBtn">Medium</button>
      <button id="hardBtn">Hard</button>
      <button id="nightBtn">Nightmare</button>
      <span class="muted" id="menuHint">Pick one to start</span>
    </div>

    <div class="box row" id="hudBox" style="display:none;">
      <div>üî¶ Flash: <b id="flashVal">100.0%</b></div>
      <div>üö™ Door: <b id="doorVal">100.0%</b></div>
      <div>Mode: <b id="modeVal">‚Äî</b></div>
      <div>Enemies: <b id="enemyVal">‚Äî</b></div>
      <button id="restartBtn">Restart</button>
    </div>
  </div>

  <canvas id="game" width="980" height="620"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const hudBox = document.getElementById("hudBox");
  const menuBox = document.getElementById("menuBox");
  const flashVal = document.getElementById("flashVal");
  const doorVal  = document.getElementById("doorVal");
  const modeVal  = document.getElementById("modeVal");
  const enemyVal = document.getElementById("enemyVal");

  const restartBtn = document.getElementById("restartBtn");
  const easyBtn = document.getElementById("easyBtn");
  const medBtn  = document.getElementById("medBtn");
  const hardBtn = document.getElementById("hardBtn");
  const nightBtn= document.getElementById("nightBtn");

  // ====== Your rules, encoded ======
  const DIFFS = {
    easy:     { total: 2,  speed: 0.070 },   // slow
    medium:   { total: 4,  speed: 0.095 },   // ok
    hard:     { total: 7,  speed: 0.120 },   // medium-fast
    nightmare:{ total: 10, speed: 0.150 },   // fast
  };

  // Drain rules per your spec
  const FLASH_DRAIN_PER_SEC = 0.1; // 0.1% per second when flashlight ON
  const DOOR_DRAIN_PER_SEC  = 0.2; // 0.2% per second per closed door IF enemies in that section

  // Flashlight beam size (small so you must find individually)
  const BEAM_RADIUS = 42;

  // Door location in each corridor (near center). Enemies stop here if door closed + door battery > 0.
  const DOOR_PROGRESS = 0.78; // 0 far -> 1 at control room

  // Lose when enemy reaches center (>= 1)
  const LOSE_PROGRESS = 1.0;

  // ====== Layout: 5 sections around center ======
  const center = { x: canvas.width/2, y: canvas.height/2 + 10 };
  const roomRadius = 68;

  // Angles for 5 sections (degrees around you)
  // Top, top-right, bottom-right, bottom-left, top-left-ish
  const sectionAngles = [
    -90,   // S1
    -18,   // S2
     54,   // S3
    126,   // S4
    198    // S5
  ].map(d => d * Math.PI/180);

  const corridorLen = 250;
  const corridorWidth = 92;

  // Door click bars (computed each frame)
  let doorRects = []; // {x,y,w,h, idx}

  // ====== State ======
  let running = false;
  let difficulty = null;

  let flashlightBattery = 100.0;
  let doorBattery = 100.0;
  let flashlightOn = false;

  let mouse = { x: center.x, y: center.y, inside: false };

  // doors per section
  const doors = new Array(5).fill(0).map(() => ({ closed:false }));

  // enemies: { section, progress, lateral, id }
  // progress: 0 at far end, increases toward 1 at control room
  // lateral: -1..1 offset across corridor width so you must aim precisely
  let enemies = [];

  // ====== Helpers ======
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function dist(ax, ay, bx, by) { return Math.hypot(ax-bx, ay-by); }

  function sectionToWorld(sectionIdx, progress, lateral) {
    // Compute a point along corridor axis from outer end -> center
    const ang = sectionAngles[sectionIdx];

    // Outer end point
    const outerX = center.x + Math.cos(ang) * (roomRadius + corridorLen);
    const outerY = center.y + Math.sin(ang) * (roomRadius + corridorLen);

    // Inner point near room boundary
    const innerX = center.x + Math.cos(ang) * (roomRadius + 10);
    const innerY = center.y + Math.sin(ang) * (roomRadius + 10);

    // Interpolate along corridor from outer -> inner based on progress (0..1)
    const t = clamp(progress, 0, 1);
    const x = outerX + (innerX - outerX) * t;
    const y = outerY + (innerY - outerY) * t;

    // Lateral offset perpendicular to corridor axis
    const px = -Math.sin(ang);
    const py =  Math.cos(ang);

    const off = lateral * (corridorWidth * 0.35);
    return { x: x + px*off, y: y + py*off };
  }

  function enemyIsIlluminated(enemy) {
    if (!flashlightOn) return false;
    if (flashlightBattery <= 0) return false;
    const p = sectionToWorld(enemy.section, enemy.progress, enemy.lateral);
    return dist(p.x, p.y, mouse.x, mouse.y) <= BEAM_RADIUS;
  }

  function enemiesInSection(idx) {
    return enemies.filter(e => e.section === idx);
  }

  function computeDistribution(diffKey) {
    // EXACT distributions per your message
    if (diffKey === "easy") {
      // 2 enemies total, 1 per room max: pick 2 distinct sections
      return [1,1,0,0,0].sort(() => Math.random()-0.5);
    }
    if (diffKey === "medium") {
      // 4 enemies total, 1 per room max: 4 distinct sections
      return [1,1,1,1,0].sort(() => Math.random()-0.5);
    }
    if (diffKey === "hard") {
      // 7 enemies total: 2/2/2/1/0 across 5 rooms
      return [2,2,2,1,0].sort(() => Math.random()-0.5);
    }
    // nightmare: 10 total, 2 in each room
    return [2,2,2,2,2];
  }

  function spawnEnemies(diffKey) {
    const distArr = computeDistribution(diffKey);
    const list = [];
    let id = 0;

    for (let s = 0; s < 5; s++) {
      const count = distArr[s];
      for (let k = 0; k < count; k++) {
        // Start enemies near the far end, but with some variety
        const startProg = 0.00 + Math.random()*0.12;
        // lateral placement - makes you "find them individually"
        // if 2 enemies in a room, separate them laterally
        let lat = (count === 2)
          ? (k === 0 ? -0.55 : 0.55)
          : (Math.random()*1.1 - 0.55);

        list.push({
          id: id++,
          section: s,
          progress: startProg,
          lateral: clamp(lat, -0.85, 0.85)
        });
      }
    }

    // Shuffle to avoid predictable order
    return list.sort(() => Math.random() - 0.5);
  }

  function resetAll() {
    flashlightBattery = 100.0;
    doorBattery = 100.0;
    flashlightOn = false;
    enemies = [];
    for (const d of doors) d.closed = false;
    doorRects = [];
  }

  // ====== Input ======
  canvas.addEventListener("mousemove", (e) => {
    const r = canvas.getBoundingClientRect();
    mouse.x = e.clientX - r.left;
    mouse.y = e.clientY - r.top;
    mouse.inside = (mouse.x >= 0 && mouse.x <= canvas.width && mouse.y >= 0 && mouse.y <= canvas.height);
  });

  canvas.addEventListener("mouseleave", () => mouse.inside = false);

  canvas.addEventListener("click", (e) => {
    if (!running) return;
    // Toggle door by clicking door bar
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;

    for (const dr of doorRects) {
      if (mx >= dr.x && mx <= dr.x + dr.w && my >= dr.y && my <= dr.y + dr.h) {
        // No battery backup; if door battery is 0, doors are failed open
        if (doorBattery <= 0) return;
        doors[dr.idx].closed = !doors[dr.idx].closed;
        return;
      }
    }
  });

  window.addEventListener("keydown", (e) => {
    if (!running) return;
    if (e.key.toLowerCase() === "f") {
      if (flashlightBattery > 0) flashlightOn = !flashlightOn;
    }
  });

  // ====== Menu controls ======
  function lockMenuButtons(lock) {
    [easyBtn, medBtn, hardBtn, nightBtn].forEach(b => b.disabled = lock);
  }

  function start(diffKey) {
    resetAll();
    difficulty = diffKey;
    enemies = spawnEnemies(diffKey);

    modeVal.textContent = diffKey.toUpperCase();
    enemyVal.textContent = enemies.length.toString();

    menuBox.style.display = "none";
    hudBox.style.display = "flex";
    hudBox.style.gap = "12px";
    hudBox.style.flexWrap = "wrap";

    running = true;
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  easyBtn.onclick  = () => start("easy");
  medBtn.onclick   = () => start("medium");
  hardBtn.onclick  = () => start("hard");
  nightBtn.onclick = () => start("nightmare");

  restartBtn.onclick = () => {
    running = false;
    menuBox.style.display = "flex";
    hudBox.style.display = "none";
    lockMenuButtons(false);
    resetAll();
    draw(0);
  };

  // ====== Main loop ======
  let lastTime = performance.now();

  function update(dt) {
    if (!difficulty) return;

    // Flashlight drain: 0.1% per second while ON
    if (flashlightOn && flashlightBattery > 0) {
      flashlightBattery -= FLASH_DRAIN_PER_SEC * dt;
      flashlightBattery = clamp(flashlightBattery, 0, 100);
      if (flashlightBattery <= 0) {
        flashlightOn = false;
      }
    }

    // Door drain: 0.2% per second per CLOSED door *only if that section has enemies*
    if (doorBattery > 0) {
      let drainingDoors = 0;
      for (let s = 0; s < 5; s++) {
        if (doors[s].closed && enemiesInSection(s).length > 0) drainingDoors++;
      }
      if (drainingDoors > 0) {
        doorBattery -= (DOOR_DRAIN_PER_SEC * drainingDoors) * dt;
        doorBattery = clamp(doorBattery, 0, 100);
      }
    }

    // If door battery hits 0: doors fail open permanently (your earlier rule)
    if (doorBattery <= 0) {
      for (let s = 0; s < 5; s++) doors[s].closed = false;
    }

    // Move enemies unless illuminated (freeze) or blocked by closed door
    const spd = DIFFS[difficulty].speed; // per-second progress increment

    for (const e of enemies) {
      const lit = enemyIsIlluminated(e);

      if (lit) continue; // frozen while flashlight is directly on them

      // If door is closed and powered, enemy cannot pass DOOR_PROGRESS
      const doorClosed = doors[e.section].closed && doorBattery > 0;

      if (doorClosed && e.progress >= DOOR_PROGRESS) {
        e.progress = DOOR_PROGRESS; // hold them at the door
        continue;
      }

      e.progress += spd * dt;

      // Lose if any reaches the control room
      if (e.progress >= LOSE_PROGRESS) {
        gameOver();
        return;
      }
    }
  }

  function gameOver() {
    running = false;
    alert("YOU LOST ‚Äî An enemy reached the control room.");
    // Return to menu
    menuBox.style.display = "flex";
    hudBox.style.display = "none";
    lockMenuButtons(false);
    resetAll();
    draw(0);
  }

  function loop(now) {
    if (!running) return;
    const dt = (now - lastTime) / 1000; // seconds
    lastTime = now;

    update(dt);
    draw(dt);

    requestAnimationFrame(loop);
  }

  // ====== Drawing ======
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Background grid-ish glow
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = "#1cff7a";
    for (let x = 0; x < canvas.width; x += 40) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
    }
    for (let y = 0; y < canvas.height; y += 40) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
    }
    ctx.restore();

    // Draw corridors + section labels + doors (click targets)
    doorRects = [];

    for (let s = 0; s < 5; s++) {
      const ang = sectionAngles[s];
      const ax = Math.cos(ang), ay = Math.sin(ang);
      const px = -Math.sin(ang), py = Math.cos(ang);

      // Corridor polygon
      const innerX = center.x + ax*(roomRadius + 10);
      const innerY = center.y + ay*(roomRadius + 10);
      const outerX = center.x + ax*(roomRadius + corridorLen);
      const outerY = center.y + ay*(roomRadius + corridorLen);

      const hw = corridorWidth/2;

      const p1 = { x: innerX + px*hw, y: innerY + py*hw };
      const p2 = { x: innerX - px*hw, y: innerY - py*hw };
      const p3 = { x: outerX - px*hw, y: outerY - py*hw };
      const p4 = { x: outerX + px*hw, y: outerY + py*hw };

      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "#0b1d12";
      ctx.strokeStyle = "#1cff7a55";
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.lineTo(p4.x, p4.y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // Section label near outer end
      ctx.save();
      ctx.fillStyle = "#b6ffcf";
      ctx.font = "14px monospace";
      ctx.globalAlpha = 0.9;
      ctx.fillText(`S${s+1}`, outerX - 10, outerY - 10);
      ctx.restore();

      // Door bar position at DOOR_PROGRESS
      const doorPoint = sectionToWorld(s, DOOR_PROGRESS, 0);
      const barW = corridorWidth * 0.72;
      const barH = 12;

      // Door rect oriented roughly perpendicular: draw as axis-aligned for clicking simplicity
      const dr = {
        idx: s,
        x: doorPoint.x - barW/2,
        y: doorPoint.y - barH/2,
        w: barW,
        h: barH
      };
      doorRects.push(dr);

      // Draw door bar
      const doorIsClosed = doors[s].closed && doorBattery > 0;
      ctx.save();
      ctx.fillStyle = doorIsClosed ? "#1cff7a" : "#1cff7a22";
      ctx.strokeStyle = "#1cff7a66";
      ctx.lineWidth = 2;
      ctx.fillRect(dr.x, dr.y, dr.w, dr.h);
      ctx.strokeRect(dr.x, dr.y, dr.w, dr.h);

      ctx.fillStyle = "#041006";
      ctx.globalAlpha = doorIsClosed ? 0.95 : 0.55;
      ctx.font = "11px monospace";
      ctx.fillText(doorIsClosed ? "TRAP CLOSED" : "TRAP OPEN", dr.x + 8, dr.y + 9);
      ctx.restore();
    }

    // Draw control room
    ctx.save();
    ctx.fillStyle = "#071a10";
    ctx.strokeStyle = "#1cff7a88";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(center.x, center.y, roomRadius, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "#caffdd";
    ctx.font = "16px monospace";
    ctx.fillText("CONTROL ROOM", center.x - 68, center.y + 6);
    ctx.restore();

    // Draw flashlight beam (small circle you aim)
    if (running && flashlightOn && flashlightBattery > 0 && mouse.inside) {
      ctx.save();
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(mouse.x, mouse.y, BEAM_RADIUS, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.45;
      ctx.strokeStyle = "#d6ffd6";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(mouse.x, mouse.y, BEAM_RADIUS, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // Draw enemies ONLY if beam hits them (must find individually)
    for (const e of enemies) {
      const p = sectionToWorld(e.section, e.progress, e.lateral);
      const lit = enemyIsIlluminated(e);

      if (!lit) continue; // invisible unless directly lit

      ctx.save();
      // Enemy dot
      ctx.fillStyle = "#ff2a2a";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
      ctx.fill();

      // Tiny ‚Äúfreeze‚Äù indicator
      ctx.strokeStyle = "#ffd1d1";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 14, 0, Math.PI*2);
      ctx.stroke();

      ctx.font = "10px monospace";
      ctx.fillStyle = "#ffd1d1";
      ctx.fillText("FOUND", p.x - 16, p.y - 16);
      ctx.restore();
    }

    // HUD update
    flashVal.textContent = `${flashlightBattery.toFixed(1)}%`;
    doorVal.textContent  = `${doorBattery.toFixed(1)}%`;
  }

  // First draw (menu screen)
  draw(0);
})();
</script>
</body>
</html>
